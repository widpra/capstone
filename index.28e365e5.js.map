{"mappings":"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","sources":["<anon>","src/js/main.js","src/js/shuffle.js"],"sourcesContent":["/* global $ */ var $1825d10ebdabed7b$exports = {};\nfunction $1825d10ebdabed7b$var$shuffle(a) {\n    for(let i = a.length - 1; i > 0; i--){\n        const j = Math.floor(Math.random() * (i + 1));\n        [a[i], a[j]] = [\n            a[j],\n            a[i]\n        ];\n    }\n    return a;\n}\n$1825d10ebdabed7b$exports = $1825d10ebdabed7b$var$shuffle; //This should be the last line in the file\n\n\n// const shuffle = require('./shuffle');\nfunction $54b47fc030b7b21e$var$rand(max) {\n    return Math.floor(Math.random() * max);\n}\nfunction $54b47fc030b7b21e$var$changeBrightness(factor, sprite) {\n    const virtCanvas = document.createElement(\"canvas\");\n    virtCanvas.width = 500;\n    virtCanvas.height = 500;\n    const context = virtCanvas.getContext(\"2d\");\n    context.drawImage(sprite, 0, 0, 500, 500);\n    const imgData = context.getImageData(0, 0, 500, 500);\n    for(let i = 0; i < imgData.data.length; i += 4){\n        imgData.data[i] = imgData.data[i] * factor;\n        imgData.data[i + 1] = imgData.data[i + 1] * factor;\n        imgData.data[i + 2] = imgData.data[i + 2] * factor;\n    }\n    context.putImageData(imgData, 0, 0);\n    const spriteOutput = new Image();\n    spriteOutput.src = virtCanvas.toDataURL();\n    virtCanvas.remove();\n    return spriteOutput;\n}\nfunction $54b47fc030b7b21e$var$displayVictoryMess(moves) {\n    document.getElementById(\"moves\").innerHTML = `You Moved ${moves} Steps.`;\n    $54b47fc030b7b21e$var$toggleVisablity(\"Message-Container\");\n}\nfunction $54b47fc030b7b21e$var$toggleVisablity(id) {\n    if (document.getElementById(id).style.visibility == \"visible\") document.getElementById(id).style.visibility = \"hidden\";\n    else document.getElementById(id).style.visibility = \"visible\";\n}\nfunction $54b47fc030b7b21e$var$Maze(Width, Height) {\n    let mazeMap;\n    const width = Width;\n    const height = Height;\n    let startCoord, endCoord;\n    const dirs = [\n        \"n\",\n        \"s\",\n        \"e\",\n        \"w\"\n    ];\n    const modDir = {\n        n: {\n            y: -1,\n            x: 0,\n            o: \"s\"\n        },\n        s: {\n            y: 1,\n            x: 0,\n            o: \"n\"\n        },\n        e: {\n            y: 0,\n            x: 1,\n            o: \"w\"\n        },\n        w: {\n            y: 0,\n            x: -1,\n            o: \"e\"\n        }\n    };\n    this.map = function() {\n        return mazeMap;\n    };\n    this.startCoord = function() {\n        return startCoord;\n    };\n    this.endCoord = function() {\n        return endCoord;\n    };\n    function genMap() {\n        mazeMap = new Array(height);\n        for(let y = 0; y < height; y++){\n            mazeMap[y] = new Array(width);\n            for(let x = 0; x < width; ++x)mazeMap[y][x] = {\n                n: false,\n                s: false,\n                e: false,\n                w: false,\n                visited: false,\n                priorPos: null\n            };\n        }\n    }\n    function defineMaze() {\n        let isComp = false;\n        let move = false;\n        let cellsVisited = 1;\n        let numLoops = 0;\n        let maxLoops = 0;\n        let pos = {\n            x: 0,\n            y: 0\n        };\n        const numCells = width * height;\n        while(!isComp){\n            move = false;\n            mazeMap[pos.x][pos.y].visited = true;\n            if (numLoops >= maxLoops) {\n                (0, $1825d10ebdabed7b$exports.shuffle)(dirs);\n                maxLoops = Math.round($54b47fc030b7b21e$var$rand(height / 8));\n                numLoops = 0;\n            }\n            numLoops++;\n            for(let index = 0; index < dirs.length; index++){\n                const direction = dirs[index];\n                const nx = pos.x + modDir[direction].x;\n                const ny = pos.y + modDir[direction].y;\n                if (nx >= 0 && nx < width && ny >= 0 && ny < height) // Check if the tile is already visited\n                {\n                    if (!mazeMap[nx][ny].visited) {\n                        // Carve through walls from this tile to next\n                        mazeMap[pos.x][pos.y][direction] = true;\n                        mazeMap[nx][ny][modDir[direction].o] = true;\n                        // Set Currentcell as next cells Prior visited\n                        mazeMap[nx][ny].priorPos = pos;\n                        // Update Cell position to newly visited location\n                        pos = {\n                            x: nx,\n                            y: ny\n                        };\n                        cellsVisited++;\n                        // Recursively call this method on the next tile\n                        move = true;\n                        break;\n                    }\n                }\n            }\n            if (!move) //  If it failed to find a direction,\n            //  move the current position back to the prior cell and Recall the method.\n            pos = mazeMap[pos.x][pos.y].priorPos;\n            if (numCells == cellsVisited) isComp = true;\n        }\n    }\n    function defineStartEnd() {\n        switch($54b47fc030b7b21e$var$rand(4)){\n            case 0:\n                startCoord = {\n                    x: 0,\n                    y: 0\n                };\n                endCoord = {\n                    x: height - 1,\n                    y: width - 1\n                };\n                break;\n            case 1:\n                startCoord = {\n                    x: 0,\n                    y: width - 1\n                };\n                endCoord = {\n                    x: height - 1,\n                    y: 0\n                };\n                break;\n            case 2:\n                startCoord = {\n                    x: height - 1,\n                    y: 0\n                };\n                endCoord = {\n                    x: 0,\n                    y: width - 1\n                };\n                break;\n            case 3:\n                startCoord = {\n                    x: height - 1,\n                    y: width - 1\n                };\n                endCoord = {\n                    x: 0,\n                    y: 0\n                };\n                break;\n        }\n    }\n    genMap();\n    defineStartEnd();\n    defineMaze();\n}\nfunction $54b47fc030b7b21e$var$DrawMaze(Maze, ctx, cellsize, endSprite = null) {\n    const map = Maze.map();\n    let cellSize = cellsize;\n    let drawEndMethod;\n    ctx.lineWidth = cellSize / 40;\n    this.redrawMaze = function(size) {\n        cellSize = size;\n        ctx.lineWidth = cellSize / 50;\n        drawMap();\n        drawEndMethod();\n    };\n    function drawCell(xCord, yCord, cell) {\n        const x = xCord * cellSize;\n        const y = yCord * cellSize;\n        if (cell.n === false) {\n            ctx.beginPath();\n            ctx.moveTo(x, y);\n            ctx.lineTo(x + cellSize, y);\n            ctx.stroke();\n        }\n        if (cell.s === false) {\n            ctx.beginPath();\n            ctx.moveTo(x, y + cellSize);\n            ctx.lineTo(x + cellSize, y + cellSize);\n            ctx.stroke();\n        }\n        if (cell.e === false) {\n            ctx.beginPath();\n            ctx.moveTo(x + cellSize, y);\n            ctx.lineTo(x + cellSize, y + cellSize);\n            ctx.stroke();\n        }\n        if (cell.w == false) {\n            ctx.beginPath();\n            ctx.moveTo(x, y);\n            ctx.lineTo(x, y + cellSize);\n            ctx.stroke();\n        }\n    }\n    function drawMap() {\n        for(let x = 0; x < map.length; x++)for(let y = 0; y < map[x].length; y++)drawCell(x, y, map[x][y]);\n    }\n    function drawEndFlag() {\n        const coord = Maze.endCoord();\n        const gridSize = 4;\n        const fraction = cellSize / gridSize - 2;\n        let colorSwap = true;\n        for(let y = 0; y < gridSize; y++){\n            if (gridSize % 2 === 0) colorSwap = !colorSwap;\n            for(let x = 0; x < gridSize; x++){\n                ctx.beginPath();\n                ctx.rect(coord.x * cellSize + x * fraction + 4.5, coord.y * cellSize + y * fraction + 4.5, fraction, fraction);\n                if (colorSwap) ctx.fillStyle = \"rgba(0, 0, 0, 0.8)\";\n                else ctx.fillStyle = \"rgba(255, 255, 255, 0.8)\";\n                ctx.fill();\n                colorSwap = !colorSwap;\n            }\n        }\n    }\n    function drawEndSprite() {\n        const offsetLeft = cellSize / 50;\n        const offsetRight = cellSize / 25;\n        const coord = Maze.endCoord();\n        ctx.drawImage(endSprite, 2, 2, endSprite.width, endSprite.height, coord.x * cellSize + offsetLeft, coord.y * cellSize + offsetLeft, cellSize - offsetRight, cellSize - offsetRight);\n    }\n    function clear() {\n        const canvasSize = cellSize * map.length;\n        ctx.clearRect(0, 0, canvasSize, canvasSize);\n    }\n    if (endSprite != null) drawEndMethod = drawEndSprite;\n    else drawEndMethod = drawEndFlag;\n    clear();\n    drawMap();\n    drawEndMethod();\n}\nfunction $54b47fc030b7b21e$var$Player(maze, c, _cellsize, onComplete, sprite = null) {\n    const ctx = c.getContext(\"2d\");\n    let drawSprite;\n    let moves = 0;\n    drawSprite = drawSpriteCircle;\n    if (sprite != null) drawSprite = drawSpriteImg;\n    const player = this;\n    const map = maze.map();\n    let cellCoords = {\n        x: maze.startCoord().x,\n        y: maze.startCoord().y\n    };\n    let cellSize = _cellsize;\n    const halfCellSize = cellSize / 2;\n    this.redrawPlayer = function(_cellsize) {\n        cellSize = _cellsize;\n        drawSpriteImg(cellCoords);\n    };\n    function drawSpriteCircle(coord) {\n        ctx.beginPath();\n        ctx.fillStyle = \"yellow\";\n        ctx.arc((coord.x + 1) * cellSize - halfCellSize, (coord.y + 1) * cellSize - halfCellSize, halfCellSize - 2, 0, 2 * Math.PI);\n        ctx.fill();\n        if (coord.x === maze.endCoord().x && coord.y === maze.endCoord().y) {\n            onComplete(moves);\n            player.unbindKeyDown();\n        }\n    }\n    function drawSpriteImg(coord) {\n        const offsetLeft = cellSize / 50;\n        const offsetRight = cellSize / 25;\n        ctx.drawImage(sprite, 0, 0, sprite.width, sprite.height, coord.x * cellSize + offsetLeft, coord.y * cellSize + offsetLeft, cellSize - offsetRight, cellSize - offsetRight);\n        if (coord.x === maze.endCoord().x && coord.y === maze.endCoord().y) {\n            onComplete(moves);\n            player.unbindKeyDown();\n        }\n    }\n    function removeSprite(coord) {\n        const offsetLeft = cellSize / 50;\n        const offsetRight = cellSize / 25;\n        ctx.clearRect(coord.x * cellSize + offsetLeft, coord.y * cellSize + offsetLeft, cellSize - offsetRight, cellSize - offsetRight);\n    }\n    function check(e) {\n        const cell = map[cellCoords.x][cellCoords.y];\n        moves++;\n        switch(e.keyCode){\n            case 65:\n            case 37:\n                if (cell.w === true) {\n                    removeSprite(cellCoords);\n                    cellCoords = {\n                        x: cellCoords.x - 1,\n                        y: cellCoords.y\n                    };\n                    drawSprite(cellCoords);\n                }\n                break;\n            case 87:\n            case 38:\n                if (cell.n === true) {\n                    removeSprite(cellCoords);\n                    cellCoords = {\n                        x: cellCoords.x,\n                        y: cellCoords.y - 1\n                    };\n                    drawSprite(cellCoords);\n                }\n                break;\n            case 68:\n            case 39:\n                if (cell.e === true) {\n                    removeSprite(cellCoords);\n                    cellCoords = {\n                        x: cellCoords.x + 1,\n                        y: cellCoords.y\n                    };\n                    drawSprite(cellCoords);\n                }\n                break;\n            case 83:\n            case 40:\n                if (cell.s === true) {\n                    removeSprite(cellCoords);\n                    cellCoords = {\n                        x: cellCoords.x,\n                        y: cellCoords.y + 1\n                    };\n                    drawSprite(cellCoords);\n                }\n                break;\n        }\n    }\n    this.bindKeyDown = function() {\n        window.addEventListener(\"keydown\", check, false);\n        $(\"#view\").swipe({\n            swipe: function(event, direction) {\n                console.log(direction);\n                switch(direction){\n                    case \"up\":\n                        check({\n                            keyCode: 38\n                        });\n                        break;\n                    case \"down\":\n                        check({\n                            keyCode: 40\n                        });\n                        break;\n                    case \"left\":\n                        check({\n                            keyCode: 37\n                        });\n                        break;\n                    case \"right\":\n                        check({\n                            keyCode: 39\n                        });\n                        break;\n                }\n            },\n            threshold: 0\n        });\n    };\n    this.unbindKeyDown = function() {\n        window.removeEventListener(\"keydown\", check, false);\n        $(\"#view\").swipe(\"destroy\");\n    };\n    drawSprite(maze.startCoord());\n    this.bindKeyDown();\n}\nconst $54b47fc030b7b21e$var$mazeCanvas = document.getElementById(\"mazeCanvas\");\nconst $54b47fc030b7b21e$var$ctx = $54b47fc030b7b21e$var$mazeCanvas.getContext(\"2d\");\nlet $54b47fc030b7b21e$var$sprite;\nlet $54b47fc030b7b21e$var$finishSprite;\nlet $54b47fc030b7b21e$var$maze, $54b47fc030b7b21e$var$draw, $54b47fc030b7b21e$var$player;\nlet $54b47fc030b7b21e$var$cellSize;\nlet $54b47fc030b7b21e$var$difficulty;\n// sprite.src = 'media/sprite.png';\nwindow.onload = function() {\n    const viewWidth = $(\"#view\").width();\n    const viewHeight = $(\"#view\").height();\n    if (viewHeight < viewWidth) {\n        $54b47fc030b7b21e$var$ctx.canvas.width = viewHeight - viewHeight / 100;\n        $54b47fc030b7b21e$var$ctx.canvas.height = viewHeight - viewHeight / 100;\n    } else {\n        $54b47fc030b7b21e$var$ctx.canvas.width = viewWidth - viewWidth / 100;\n        $54b47fc030b7b21e$var$ctx.canvas.height = viewWidth - viewWidth / 100;\n    }\n    // Load and edit sprites\n    let completeOne = false;\n    let completeTwo = false;\n    const isComplete = ()=>{\n        if (completeOne === true && completeTwo === true) {\n            console.log(\"Runs\");\n            setTimeout(()=>{\n                $54b47fc030b7b21e$var$makeMaze();\n            }, 500);\n        }\n    };\n    $54b47fc030b7b21e$var$sprite = new Image();\n    $54b47fc030b7b21e$var$sprite.src = \"https://image.ibb.co/dr1HZy/Pf_RWr3_X_Imgur.png\" + `?${new Date().getTime()}`;\n    $54b47fc030b7b21e$var$sprite.setAttribute(\"crossOrigin\", \" \");\n    $54b47fc030b7b21e$var$sprite.onload = function() {\n        $54b47fc030b7b21e$var$sprite = $54b47fc030b7b21e$var$changeBrightness(1.2, $54b47fc030b7b21e$var$sprite);\n        completeOne = true;\n        console.log(completeOne);\n        isComplete();\n    };\n    $54b47fc030b7b21e$var$finishSprite = new Image();\n    $54b47fc030b7b21e$var$finishSprite.src = \"https://image.ibb.co/b9wqnJ/i_Q7m_U25_Imgur.png\" + `?${new Date().getTime()}`;\n    $54b47fc030b7b21e$var$finishSprite.setAttribute(\"crossOrigin\", \" \");\n    $54b47fc030b7b21e$var$finishSprite.onload = function() {\n        $54b47fc030b7b21e$var$finishSprite = $54b47fc030b7b21e$var$changeBrightness(1.1, $54b47fc030b7b21e$var$finishSprite);\n        completeTwo = true;\n        console.log(completeTwo);\n        isComplete();\n    };\n};\nwindow.onresize = function() {\n    const viewWidth = $(\"#view\").width();\n    const viewHeight = $(\"#view\").height();\n    if (viewHeight < viewWidth) {\n        $54b47fc030b7b21e$var$ctx.canvas.width = viewHeight - viewHeight / 100;\n        $54b47fc030b7b21e$var$ctx.canvas.height = viewHeight - viewHeight / 100;\n    } else {\n        $54b47fc030b7b21e$var$ctx.canvas.width = viewWidth - viewWidth / 100;\n        $54b47fc030b7b21e$var$ctx.canvas.height = viewWidth - viewWidth / 100;\n    }\n    $54b47fc030b7b21e$var$cellSize = $54b47fc030b7b21e$var$mazeCanvas.width / $54b47fc030b7b21e$var$difficulty;\n    if ($54b47fc030b7b21e$var$player != null) {\n        $54b47fc030b7b21e$var$draw.redrawMaze($54b47fc030b7b21e$var$cellSize);\n        $54b47fc030b7b21e$var$player.redrawPlayer($54b47fc030b7b21e$var$cellSize);\n    }\n};\nfunction $54b47fc030b7b21e$var$makeMaze() {\n    // document.getElementById(\"mazeCanvas\").classList.add(\"border\");\n    if ($54b47fc030b7b21e$var$player !== undefined) {\n        $54b47fc030b7b21e$var$player.unbindKeyDown();\n        $54b47fc030b7b21e$var$player = null;\n    }\n    const e = document.getElementById(\"diffSelect\");\n    $54b47fc030b7b21e$var$difficulty = e.options[e.selectedIndex].value;\n    $54b47fc030b7b21e$var$cellSize = $54b47fc030b7b21e$var$mazeCanvas.width / $54b47fc030b7b21e$var$difficulty;\n    $54b47fc030b7b21e$var$maze = new $54b47fc030b7b21e$var$Maze($54b47fc030b7b21e$var$difficulty, $54b47fc030b7b21e$var$difficulty);\n    $54b47fc030b7b21e$var$draw = new $54b47fc030b7b21e$var$DrawMaze($54b47fc030b7b21e$var$maze, $54b47fc030b7b21e$var$ctx, $54b47fc030b7b21e$var$cellSize, $54b47fc030b7b21e$var$finishSprite);\n    $54b47fc030b7b21e$var$player = new $54b47fc030b7b21e$var$Player($54b47fc030b7b21e$var$maze, $54b47fc030b7b21e$var$mazeCanvas, $54b47fc030b7b21e$var$cellSize, $54b47fc030b7b21e$var$displayVictoryMess, $54b47fc030b7b21e$var$sprite);\n    if (document.getElementById(\"mazeContainer\").style.opacity < \"100\") document.getElementById(\"mazeContainer\").style.opacity = \"100\";\n}\n\n\n//# sourceMappingURL=index.28e365e5.js.map\n","/* global $ */\n\nimport { shuffle } from './shuffle';\n// const shuffle = require('./shuffle');\n\nfunction rand (max) {\n  return Math.floor(Math.random() * max)\n}\n\nfunction changeBrightness (factor, sprite) {\n  const virtCanvas = document.createElement('canvas')\n  virtCanvas.width = 500\n  virtCanvas.height = 500\n  const context = virtCanvas.getContext('2d')\n  context.drawImage(sprite, 0, 0, 500, 500);\n\n  const imgData = context.getImageData(0, 0, 500, 500)\n\n  for (let i = 0; i < imgData.data.length; i += 4) {\n    imgData.data[i] = imgData.data[i] * factor\n    imgData.data[i + 1] = imgData.data[i + 1] * factor\n    imgData.data[i + 2] = imgData.data[i + 2] * factor\n  }\n  context.putImageData(imgData, 0, 0)\n\n  const spriteOutput = new Image()\n  spriteOutput.src = virtCanvas.toDataURL()\n  virtCanvas.remove()\n  return spriteOutput\n}\n\nfunction displayVictoryMess (moves) {\n  document.getElementById('moves').innerHTML = `You Moved ${moves} Steps.`\n  toggleVisablity('Message-Container')\n}\n\nfunction toggleVisablity (id) {\n  if (document.getElementById(id).style.visibility == 'visible') {\n    document.getElementById(id).style.visibility = 'hidden'\n  } else {\n    document.getElementById(id).style.visibility = 'visible'\n  }\n}\n\nfunction Maze (Width, Height) {\n  let mazeMap\n  const width = Width\n  const height = Height\n  let startCoord,\n    endCoord\n  const dirs = ['n', 's', 'e', 'w']\n  const modDir = {\n    n: {\n      y: -1,\n      x: 0,\n      o: 's'\n    },\n    s: {\n      y: 1,\n      x: 0,\n      o: 'n'\n    },\n    e: {\n      y: 0,\n      x: 1,\n      o: 'w'\n    },\n    w: {\n      y: 0,\n      x: -1,\n      o: 'e'\n    }\n  }\n\n  this.map = function () {\n    return mazeMap\n  }\n  this.startCoord = function () {\n    return startCoord\n  }\n  this.endCoord = function () {\n    return endCoord\n  }\n\n  function genMap () {\n    mazeMap = new Array(height)\n    for (let y = 0; y < height; y++) {\n      mazeMap[y] = new Array(width)\n      for (let x = 0; x < width; ++x) {\n        mazeMap[y][x] = {\n          n: false,\n          s: false,\n          e: false,\n          w: false,\n          visited: false,\n          priorPos: null\n        }\n      }\n    }\n  }\n\n  function defineMaze () {\n    let isComp = false\n    let move = false;\n    let cellsVisited = 1\n    let numLoops = 0\n    let maxLoops = 0\n    let pos = {\n      x: 0,\n      y: 0\n    }\n    const numCells = width * height\n    while (!isComp) {\n      move = false\n      mazeMap[pos.x][pos.y].visited = true\n\n      if (numLoops >= maxLoops) {\n        shuffle(dirs)\n        maxLoops = Math.round(rand(height / 8))\n        numLoops = 0\n      }\n      numLoops++\n      for (let index = 0; index < dirs.length; index++) {\n        const direction = dirs[index]\n        const nx = pos.x + modDir[direction].x\n        const ny = pos.y + modDir[direction].y\n\n        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {\n          // Check if the tile is already visited\n          if (!mazeMap[nx][ny].visited) {\n            // Carve through walls from this tile to next\n            mazeMap[pos.x][pos.y][direction] = true\n            mazeMap[nx][ny][modDir[direction].o] = true\n\n            // Set Currentcell as next cells Prior visited\n            mazeMap[nx][ny].priorPos = pos\n            // Update Cell position to newly visited location\n            pos = {\n              x: nx,\n              y: ny\n            }\n            cellsVisited++\n            // Recursively call this method on the next tile\n            move = true\n            break\n          }\n        }\n      }\n\n      if (!move) {\n        //  If it failed to find a direction,\n        //  move the current position back to the prior cell and Recall the method.\n        pos = mazeMap[pos.x][pos.y].priorPos\n      }\n      if (numCells == cellsVisited) {\n        isComp = true\n      }\n    }\n  }\n\n  function defineStartEnd () {\n    switch (rand(4)) {\n      case 0:\n        startCoord = {\n          x: 0,\n          y: 0\n        }\n        endCoord = {\n          x: height - 1,\n          y: width - 1\n        }\n        break\n      case 1:\n        startCoord = {\n          x: 0,\n          y: width - 1\n        }\n        endCoord = {\n          x: height - 1,\n          y: 0\n        }\n        break\n      case 2:\n        startCoord = {\n          x: height - 1,\n          y: 0\n        }\n        endCoord = {\n          x: 0,\n          y: width - 1\n        }\n        break\n      case 3:\n        startCoord = {\n          x: height - 1,\n          y: width - 1\n        }\n        endCoord = {\n          x: 0,\n          y: 0\n        }\n        break\n    }\n  }\n\n  genMap()\n  defineStartEnd()\n  defineMaze()\n}\n\nfunction DrawMaze (Maze, ctx, cellsize, endSprite = null) {\n  const map = Maze.map()\n  let cellSize = cellsize\n  let drawEndMethod\n  ctx.lineWidth = cellSize / 40\n\n  this.redrawMaze = function (size) {\n    cellSize = size\n    ctx.lineWidth = cellSize / 50\n    drawMap()\n    drawEndMethod()\n  }\n\n  function drawCell (xCord, yCord, cell) {\n    const x = xCord * cellSize\n    const y = yCord * cellSize\n\n    if (cell.n === false) {\n      ctx.beginPath()\n      ctx.moveTo(x, y)\n      ctx.lineTo(x + cellSize, y)\n      ctx.stroke()\n    }\n    if (cell.s === false) {\n      ctx.beginPath()\n      ctx.moveTo(x, y + cellSize)\n      ctx.lineTo(x + cellSize, y + cellSize)\n      ctx.stroke()\n    }\n    if (cell.e === false) {\n      ctx.beginPath()\n      ctx.moveTo(x + cellSize, y)\n      ctx.lineTo(x + cellSize, y + cellSize)\n      ctx.stroke()\n    }\n    if (cell.w == false) {\n      ctx.beginPath()\n      ctx.moveTo(x, y)\n      ctx.lineTo(x, y + cellSize)\n      ctx.stroke();\n    }\n  }\n\n  function drawMap () {\n    for (let x = 0; x < map.length; x++) {\n      for (let y = 0; y < map[x].length; y++) {\n        drawCell(x, y, map[x][y])\n      }\n    }\n  }\n\n  function drawEndFlag () {\n    const coord = Maze.endCoord()\n    const gridSize = 4\n    const fraction = cellSize / gridSize - 2\n    let colorSwap = true\n    for (let y = 0; y < gridSize; y++) {\n      if (gridSize % 2 === 0) {\n        colorSwap = !colorSwap\n      }\n      for (let x = 0; x < gridSize; x++) {\n        ctx.beginPath()\n        ctx.rect(\n          coord.x * cellSize + x * fraction + 4.5,\n          coord.y * cellSize + y * fraction + 4.5,\n          fraction,\n          fraction\n        )\n        if (colorSwap) {\n          ctx.fillStyle = 'rgba(0, 0, 0, 0.8)'\n        } else {\n          ctx.fillStyle = 'rgba(255, 255, 255, 0.8)'\n        }\n        ctx.fill()\n        colorSwap = !colorSwap\n      }\n    }\n  }\n\n  function drawEndSprite () {\n    const offsetLeft = cellSize / 50\n    const offsetRight = cellSize / 25\n    const coord = Maze.endCoord()\n    ctx.drawImage(\n      endSprite,\n      2,\n      2,\n      endSprite.width,\n      endSprite.height,\n      coord.x * cellSize + offsetLeft,\n      coord.y * cellSize + offsetLeft,\n      cellSize - offsetRight,\n      cellSize - offsetRight\n    )\n  }\n\n  function clear () {\n    const canvasSize = cellSize * map.length\n    ctx.clearRect(0, 0, canvasSize, canvasSize)\n  }\n\n  if (endSprite != null) {\n    drawEndMethod = drawEndSprite\n  } else {\n    drawEndMethod = drawEndFlag\n  }\n  clear()\n  drawMap()\n  drawEndMethod()\n}\n\nfunction Player (maze, c, _cellsize, onComplete, sprite = null) {\n  const ctx = c.getContext('2d')\n  let drawSprite\n  let moves = 0\n  drawSprite = drawSpriteCircle\n  if (sprite != null) {\n    drawSprite = drawSpriteImg\n  }\n  const player = this\n  const map = maze.map()\n  let cellCoords = {\n    x: maze.startCoord().x,\n    y: maze.startCoord().y\n  }\n  let cellSize = _cellsize\n  const halfCellSize = cellSize / 2\n\n  this.redrawPlayer = function (_cellsize) {\n    cellSize = _cellsize\n    drawSpriteImg(cellCoords)\n  }\n\n  function drawSpriteCircle (coord) {\n    ctx.beginPath()\n    ctx.fillStyle = 'yellow'\n    ctx.arc(\n      (coord.x + 1) * cellSize - halfCellSize,\n      (coord.y + 1) * cellSize - halfCellSize,\n      halfCellSize - 2,\n      0,\n      2 * Math.PI\n    )\n    ctx.fill()\n    if (coord.x === maze.endCoord().x && coord.y === maze.endCoord().y) {\n      onComplete(moves)\n      player.unbindKeyDown()\n    }\n  }\n\n  function drawSpriteImg (coord) {\n    const offsetLeft = cellSize / 50\n    const offsetRight = cellSize / 25\n    ctx.drawImage(\n      sprite,\n      0,\n      0,\n      sprite.width,\n      sprite.height,\n      coord.x * cellSize + offsetLeft,\n      coord.y * cellSize + offsetLeft,\n      cellSize - offsetRight,\n      cellSize - offsetRight\n    )\n    if (coord.x === maze.endCoord().x && coord.y === maze.endCoord().y) {\n      onComplete(moves)\n      player.unbindKeyDown()\n    }\n  }\n\n  function removeSprite (coord) {\n    const offsetLeft = cellSize / 50\n    const offsetRight = cellSize / 25\n    ctx.clearRect(\n      coord.x * cellSize + offsetLeft,\n      coord.y * cellSize + offsetLeft,\n      cellSize - offsetRight,\n      cellSize - offsetRight\n    )\n  }\n\n  function check (e) {\n    const cell = map[cellCoords.x][cellCoords.y]\n    moves++\n    switch (e.keyCode) {\n      case 65:\n      case 37: // west\n        if (cell.w === true) {\n          removeSprite(cellCoords)\n          cellCoords = {\n            x: cellCoords.x - 1,\n            y: cellCoords.y\n          }\n          drawSprite(cellCoords)\n        }\n        break\n      case 87:\n      case 38: // north\n        if (cell.n === true) {\n          removeSprite(cellCoords)\n          cellCoords = {\n            x: cellCoords.x,\n            y: cellCoords.y - 1\n          }\n          drawSprite(cellCoords)\n        }\n        break\n      case 68:\n      case 39: // east\n        if (cell.e === true) {\n          removeSprite(cellCoords)\n          cellCoords = {\n            x: cellCoords.x + 1,\n            y: cellCoords.y\n          }\n          drawSprite(cellCoords)\n        }\n        break\n      case 83:\n      case 40: // south\n        if (cell.s === true) {\n          removeSprite(cellCoords)\n          cellCoords = {\n            x: cellCoords.x,\n            y: cellCoords.y + 1\n          }\n          drawSprite(cellCoords)\n        }\n        break\n    }\n  }\n\n  this.bindKeyDown = function () {\n    window.addEventListener('keydown', check, false)\n\n    $('#view').swipe({\n      swipe: function (\n        event,\n        direction,\n      ) {\n        console.log(direction)\n        switch (direction) {\n          case 'up':\n            check({\n              keyCode: 38\n            })\n            break\n          case 'down':\n            check({\n              keyCode: 40\n            })\n            break\n          case 'left':\n            check({\n              keyCode: 37\n            })\n            break\n          case 'right':\n            check({\n              keyCode: 39\n            })\n            break\n        }\n      },\n      threshold: 0\n    })\n  }\n\n  this.unbindKeyDown = function () {\n    window.removeEventListener('keydown', check, false)\n    $('#view').swipe('destroy')\n  }\n\n  drawSprite(maze.startCoord())\n\n  this.bindKeyDown()\n}\n\nconst mazeCanvas = document.getElementById('mazeCanvas')\nconst ctx = mazeCanvas.getContext('2d')\nlet sprite\nlet finishSprite\nlet maze,\n  draw,\n  player\nlet cellSize\nlet difficulty\n// sprite.src = 'media/sprite.png';\n\nwindow.onload = function () {\n  const viewWidth = $('#view').width()\n  const viewHeight = $('#view').height()\n  if (viewHeight < viewWidth) {\n    ctx.canvas.width = viewHeight - viewHeight / 100\n    ctx.canvas.height = viewHeight - viewHeight / 100\n  } else {\n    ctx.canvas.width = viewWidth - viewWidth / 100\n    ctx.canvas.height = viewWidth - viewWidth / 100\n  }\n\n  // Load and edit sprites\n  let completeOne = false\n  let completeTwo = false\n  const isComplete = () => {\n    if (completeOne === true && completeTwo === true) {\n      console.log('Runs')\n      setTimeout(() => {\n        makeMaze()\n      }, 500)\n    }\n  }\n  sprite = new Image()\n  sprite.src =\n    'https://image.ibb.co/dr1HZy/Pf_RWr3_X_Imgur.png' +\n    `?${\n    new Date().getTime()}`\n  sprite.setAttribute('crossOrigin', ' ')\n  sprite.onload = function () {\n    sprite = changeBrightness(1.2, sprite)\n    completeOne = true\n    console.log(completeOne)\n    isComplete()\n  }\n\n  finishSprite = new Image()\n  finishSprite.src = 'https://image.ibb.co/b9wqnJ/i_Q7m_U25_Imgur.png' +\n  `?${\n  new Date().getTime()}`\n  finishSprite.setAttribute('crossOrigin', ' ')\n  finishSprite.onload = function () {\n    finishSprite = changeBrightness(1.1, finishSprite)\n    completeTwo = true\n    console.log(completeTwo)\n    isComplete()\n  }\n}\n\nwindow.onresize = function () {\n  const viewWidth = $('#view').width()\n  const viewHeight = $('#view').height()\n  if (viewHeight < viewWidth) {\n    ctx.canvas.width = viewHeight - viewHeight / 100\n    ctx.canvas.height = viewHeight - viewHeight / 100\n  } else {\n    ctx.canvas.width = viewWidth - viewWidth / 100\n    ctx.canvas.height = viewWidth - viewWidth / 100\n  }\n  cellSize = mazeCanvas.width / difficulty\n  if (player != null) {\n    draw.redrawMaze(cellSize)\n    player.redrawPlayer(cellSize)\n  }\n}\n\nfunction makeMaze () {\n  // document.getElementById(\"mazeCanvas\").classList.add(\"border\");\n  if (player !== undefined) {\n    player.unbindKeyDown()\n    player = null\n  }\n  const e = document.getElementById('diffSelect')\n  difficulty = e.options[e.selectedIndex].value\n  cellSize = mazeCanvas.width / difficulty\n  maze = new Maze(difficulty, difficulty)\n  draw = new DrawMaze(maze, ctx, cellSize, finishSprite)\n  player = new Player(maze, mazeCanvas, cellSize, displayVictoryMess, sprite)\n  if (document.getElementById('mazeContainer').style.opacity < '100') {\n    document.getElementById('mazeContainer').style.opacity = '100'\n  }\n}\n","function shuffle(a) {\n  for (let i = a.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [a[i], a[j]] = [a[j], a[i]];\n  }\n  return a;\n}\n\n\n\nmodule.exports = shuffle; //This should be the last line in the file"],"names":["$54b47fc030b7b21e$var$sprite","$54b47fc030b7b21e$var$finishSprite","$54b47fc030b7b21e$var$maze","$54b47fc030b7b21e$var$draw","$54b47fc030b7b21e$var$player","$54b47fc030b7b21e$var$cellSize","$54b47fc030b7b21e$var$difficulty","$1825d10ebdabed7b$exports","$54b47fc030b7b21e$var$rand","max","Math","floor","random","$54b47fc030b7b21e$var$changeBrightness","factor","sprite","virtCanvas","document","createElement","width","height","context","getContext","drawImage","imgData","getImageData","i","data","length","putImageData","spriteOutput","Image","src","toDataURL","remove","$54b47fc030b7b21e$var$displayVictoryMess","moves","id","getElementById","innerHTML","style","visibility","$54b47fc030b7b21e$var$Maze","Width","Height","mazeMap","startCoord","endCoord","dirs","modDir","n","y","x","o","s","e","w","map","genMap","Array","visited","priorPos","defineStartEnd","defineMaze","isComp","move","cellsVisited","numLoops","maxLoops","pos","numCells","shuffle","round","index","direction","nx","ny","$54b47fc030b7b21e$var$DrawMaze","Maze","ctx","cellsize","endSprite","drawEndMethod","cellSize","drawMap","drawCell","xCord","yCord","cell","beginPath","moveTo","lineTo","stroke","lineWidth","redrawMaze","size","offsetLeft","offsetRight","coord","fraction","colorSwap","rect","fillStyle","fill","clear","canvasSize","clearRect","$54b47fc030b7b21e$var$Player","maze","c","_cellsize","onComplete","drawSprite","arc","halfCellSize","PI","player","unbindKeyDown","drawSpriteImg","cellCoords","removeSprite","check","keyCode","redrawPlayer","bindKeyDown","window","addEventListener","$","swipe","event","console","log","threshold","removeEventListener","a","j","$54b47fc030b7b21e$var$mazeCanvas","$54b47fc030b7b21e$var$ctx","onload","viewWidth","viewHeight","canvas","completeOne","completeTwo","isComplete","setTimeout","$54b47fc030b7b21e$var$makeMaze","undefined","options","selectedIndex","value","opacity","Date","getTime","setAttribute","onresize"],"version":3,"file":"index.28e365e5.js.map"}